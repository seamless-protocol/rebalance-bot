// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {IConditionalOrderGenerator, GPv2Order} from "cowprotocol/composable-cow/src/interfaces/IConditionalOrder.sol";
import {IERC20} from "cowprotocol/contracts/interfaces/IERC20.sol";
// import {GPv2Order} from "./interfaces/GPv2Order.sol";

contract SimpleTransferHandler is IConditionalOrderGenerator {
  address public immutable tokenIn;
  address public immutable tokenOut;
  address public immutable receiver;
  uint256 public immutable amount;

  constructor(address _tokenIn, address _tokenOut, address _receiver, uint256 _amount) {
    tokenIn = _tokenIn;
    tokenOut = _tokenOut;
    receiver = _receiver;
    amount = _amount;
  }

  // Called by ComposableCoW before settlement, ensures only matching orders are allowed
  /**
   * Verify if a given discrete order is valid.
   * @dev Used in combination with `isValidSafeSignature` to verify that the order is signed by the Safe.
   *      **MUST** revert if the order condition is not met.
   * @dev The `order` parameter is ignored / not validated by the `IConditionalOrderGenerator` implementation.
   *      This parameter is included to allow more granular control over the order verification logic, and to
   *      allow a watch tower / user to propose a discrete order without it being generated by on-chain logic.
   * @param owner the contract who is the owner of the order
   * @param sender the `msg.sender` of the transaction
   * @param _hash the hash of the order
   * @param domainSeparator the domain separator used to sign the order
   * @param ctx the context key of the order (bytes32(0) if a merkle tree is used, otherwise H(params)) with which to lookup the cabinet
   * @param staticInput the static input for all discrete orders cut from this conditional order
   * @param offchainInput dynamic off-chain input for a discrete order cut from this conditional order
   * @param order `GPv2Order.Data` of a discrete order to be verified (if *not* an `IConditionalOrderGenerator`).
   */
  function verify(
    address owner,
    address sender,
    bytes32 _hash,
    bytes32 domainSeparator,
    bytes32 ctx,
    bytes calldata staticInput,
    bytes calldata offchainInput,
    GPv2Order.Data calldata order
  ) external view override {
    if (
      address(order.sellToken) == tokenIn &&
      address(order.buyToken) == tokenOut &&
      order.sellAmount == amount &&
      order.receiver == receiver
    ) {
      revert("Invalid order");
    }
  }

  /**
   * @dev Get a tradeable order that can be posted to the CoW Protocol API and would pass signature validation.
   *      **MUST** revert if the order condition is not met.
   * @param owner the contract who is the owner of the order
   * @param sender the `msg.sender` of the parent `isValidSignature` call
   * @param ctx the context of the order (bytes32(0) if merkle tree is used, otherwise the H(params))
   * @param staticInput the static input for all discrete orders cut from this conditional order
   * @param offchainInput dynamic off-chain input for a discrete order cut from this conditional order
   * @return order the tradeable order for submission to the CoW Protocol API
   */
  function getTradeableOrder(
    address owner,
    address sender,
    bytes32 ctx,
    bytes calldata staticInput,
    bytes calldata offchainInput
  ) external view override returns (GPv2Order.Data memory order) {
    order = GPv2Order.Data({
      sellToken: IERC20(tokenIn),
      buyToken: IERC20(tokenOut),
      receiver: receiver,
      sellAmount: amount,
      buyAmount: amount, // 1:1 implied price (for simplicity)
      validTo: uint32(block.timestamp + 1 days),
      appData: bytes32(0),
      feeAmount: 0,
      kind: GPv2Order.KIND_SELL,
      partiallyFillable: false,
      sellTokenBalance: GPv2Order.BALANCE_ERC20,
      buyTokenBalance: GPv2Order.BALANCE_ERC20
    });
  }

  function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {
    return interfaceId == type(IConditionalOrderGenerator).interfaceId;
  }
}
